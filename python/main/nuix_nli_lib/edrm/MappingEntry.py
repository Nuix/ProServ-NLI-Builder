import copy
import hashlib
import urllib
from datetime import datetime
from typing import Any, Union
from xml.dom.minidom import Document, Element

from nuix_nli_lib.edrm import FieldFactory, EntryField, EntryInterface, EDRMUtilities as eutes
from nuix_nli_lib import edrm


class MappingEntry(EntryInterface):
    """
    Generic data entry for key:value pair mappings, such as rows in a CSV file, database, or JSON file.  A MappingEntry
    generally does not represent a physical file on disk but rather is used as a vehicle for delivering Fields in a
    structured way into the final Case.

    When the target of the EDRM file is an NLI, this class will optionally produce a file in the NLI file that contains
    content that can be used as a native, whereas for other EDRM files the content will be added to an InlineContent
    element instead of a File.

    This class can, and should be subclassed when the generic means of calculating names, item dates, and text aren't
    suitable.
    """

    def __init__(self, mapping: dict[str, Any], mimetype: str, parent_id: str = None):
        """
        :param mapping: Dictionary containing the field names (keys) and their corresponding values (values)
        :param mimetype: Mimetype to assign to the item generated by this MappingEntry
        :param parent_id: Optional: ID for this entry's parent.  If a parent_id is not provided, this will be a top-
                          level item.  For mapping types it is usual to add the source of the mapping (such as the
                          CSV file or database) as the parent.
        """
        super().__init__()

        self.__data: dict[str, Any] = mapping
        self.__parent_id: str = parent_id

        self.__fill_initial_fields()
        self.__fill_generic_fields(mimetype)

    def __fill_initial_fields(self):
        """
        Internal function used to generate appropriate EntryField definitions for each field in this mapping's
        dictionary.
        """
        for key, value in self.data.items():
            if isinstance(value, bool):
                data_type = EntryField.TYPE_BOOLEAN
                _value = value
            elif isinstance(value, int):
                data_type = EntryField.TYPE_INTEGER
                _value = value
            elif isinstance(value, float):
                data_type = EntryField.TYPE_DECIMAL
                _value = value
            elif isinstance(value, datetime):
                data_type = EntryField.TYPE_DATETIME
                _value = value
            else:
                data_type = EntryField.TYPE_TEXT
                _value = str(value)

            self[key] = FieldFactory.generate_field(key, data_type, _value)

    def __fill_generic_fields(self, mimetype: str):
        """
        Internal method to add the Fields that all Items should have in a Nuix case, such as the mimetype, SHA-1 hash,
        Name, and Item Date.
        """
        self['MIME Type'] = FieldFactory.generate_field('MIME Type', EntryField.TYPE_TEXT, mimetype)
        self['Name'] = FieldFactory.generate_field('Name', EntryField.TYPE_TEXT, self.name)
        data_to_hash = copy.deepcopy(self.data)
        data_to_hash['name'] = self.get_name()
        self['SHA-1'] = FieldFactory.generate_field('SHA-1',
                                                    EntryField.TYPE_TEXT,
                                                    eutes.hash_data(data_to_hash, hashlib.sha1()))
        self['Item Date'] = FieldFactory.generate_field('Item Date', EntryField.TYPE_DATETIME, self.itemdate)

    @property
    def data(self) -> dict[str, Any]:
        return self.__data

    @property
    def identifier_field(self) -> str:
        return 'SHA-1'

    @property
    def text(self) -> str:
        """
        :return: Text to use as the content for this MappingEntry.
        """
        return str(self.data)

    def get_name(self) -> str:
        """
        Attempt to locate a name in the provided dictionary of data.  It does so in three steps:
        1. Look for the `default_rowname_field` as defined in the `edrm.configs` object
        2. If not present, look for fields with the word `name` (case-insensitive) and return the first one
        3. If no name is present, then return the first field in the row

        Note: this lookup is done on a Row-by-Row basis.  This could have negative effects, such as different rows in
        the same sequence locating different Name fields.  When possible, this work should be simplified by either
        providing the `default_rowname_field` or by centralizing the lookup so it is most likely to produce the same
        field name for all rows in a mapping sequence (all rows in a CSV file).
        """
        field_names = list(self.data.keys())
        first_field = field_names[0]
        name_fields = [f for f in field_names if 'name' in f.lower()]

        if edrm.configs['default_rowname_field'] in field_names:
            name_field = edrm.configs['default_rowname_field']
        elif len(name_fields) == 0:
            name_field = first_field
        else:
            name_field = name_fields[0]

        return str(self.data[name_field])

    @property
    def name(self) -> str:
        """
        Looks up the name field to use, then provides its value.  As the name field may be arbitrary data, and
        the name may be used as a file name stand-in, the name will be mutated to be safe to use in such a context.
        """
        name_value = self.get_name()
        name_value = eutes.sanitize_filename(name_value)
        name_value = eutes.sanitize_xml_content(name_value)

        return name_value

    @property
    def time_field(self) -> Union[str, None]:
        """
        Provide a name of a field to be used as the row items <code>Item Date</code>.  The item date is a specific
        required property used to locate data and events on a timeline.

        This method will search for time / date fields in the following order:
        1. A field with the name provided in `default_itemdate_field` property of the `edrm.configs` object
        2. A field with the word "time" (case-insensitive) in its name
        3. A field with the word "date" (case-insensitive) in its name

        Barring any of those options, None will be provided.

        If a specific field which would not be found in the above order is required, then a subclass of this class
        should be used  to override this property.

        Note: this lookup is done on a Row-by-Row basis.  This could have negative effects, such as different rows in
        the same sequence locating different Item Date fields.  When possible, this work should be simplified by either
        providing the `default_itemdate_field` or by centralizing the lookup so it is most likely to produce the same
        field name for all rows in a mapping sequence (all rows in a CSV file).
        """
        field_names = list(self.data.keys())

        if edrm.configs['default_itemdate_field'] in field_names:
            return edrm.configs['default_itemdate_field']

        time_fields = [f for f in field_names if 'time' in f.lower()]
        if len(time_fields) > 0:
            return time_fields[0]

        date_fields = [f for f in field_names if 'date' in f.lower()]
        if len(date_fields) > 0:
            return date_fields[0]

        return None

    @property
    def itemdate(self) -> Union[datetime, str]:
        """
        Attempt to lookup an item date or time for this mapping.  If there isn't one present, use "now"  This
        assumes that the values store for the field are either of the type datetime.datetime, or a string in the
        Python format provided by the `date_time_format` field in the `edrm.configs` object.  If the value is a string
        but not in the correct format, it will be returned as a String, which, while making an NLI, may make items
        misbehave in the Nuix case.
        """
        time_field = self.time_field

        if time_field is None:
            return datetime.now()
        else:
            date_time = self.data.get(time_field)

            if date_time is None:
                return datetime.now()

            if isinstance(date_time, datetime):
                return date_time

            if isinstance(date_time, str):
                try:
                    time_as_datetime = datetime.strptime(date_time, edrm.configs['date_time_format'])
                except ValueError:
                    time_as_datetime = edrm.configs['date_time_format']
                return time_as_datetime

            raise ValueError(f'Invalid item date format: {date_time}')

    @property
    def parent(self) -> str:
        return self.__parent_id

    def add_as_parent_path(self, existing_path: str):
        return self.name + '/' + existing_path

    def calculate_md5(self) -> str:
        return eutes.hash_data(self.text, hashlib.md5())

    def add_location_uri(self,
                         document: Document,
                         container: Element,
                         entry_map: dict[str, EntryInterface],
                         for_nli: bool):
        """
        See edrm.EntryInterface.add_location_uri for details about the add_location_uri method.

        A mapping will not have a representation on disk for a typical EDRM load file, as its content will be
        provided as either just a Field list, or as InlineContent, and so this method would do nothing.
        However, when `for_nli` is true, the content (text) of the mapping will be written to a representation inside
        the NLI file and the location of that file is generated here.
        """
        if for_nli:
            location_uri_element = document.createElement('LocationURI')
            location_uri = eutes.generate_relative_path(self, entry_map)
            location_uri = urllib.parse.quote_plus(location_uri, safe='/')
            location_uri_element.appendChild(document.createTextNode(location_uri))
            container.appendChild(location_uri_element)

    def serialize_content_file(self, document: Document, container: Element, entry_map: dict[str, EntryInterface]) -> None:
        """
        When the target of the EDRM load file is to be used in an NLI file, the text contents of the MappingEntry will
        be stored as a native file in the container.  This method is responsible for writing the File XML element
        used to locate the native file in the container.  By default, the file will be written to a `natives` directory
        in the NLI file.
        :param document: The DOM Document representing the EDRM load file
        :param container: The DOM Element to add the File element to
        :return: None
        """
        external_file = document.createElement('ExternalFile')
        container.appendChild(external_file)

        external_file.setAttribute('FilePath', 'natives')
        external_file.setAttribute('FileName', str(self[self.identifier_field].value))

        md5 = self.calculate_md5()
        external_file.setAttribute('Hash', md5)
        external_file.setAttribute('HashType', 'MD5')

    def add_file(self, document: Document, container: Element, entry_map: dict[str, EntryInterface], for_nli: bool):
        """
        See edrm.EntryInterface.add_file for details about the add_file method.

         How MappingEntry handles a native file depends on a few things:
         1. If there is no text content (the text property returns None) this method does nothing
         2. If the target for the EDRM file is an NLI file, this method will generate a native file
         3. Otherwise, this method will add the content as InlineContent rather than an external file
        """
        if self.text is None or len(self.text) == 0:
            return

        files_list = document.createElement('Files')
        container.appendChild(files_list)

        file_element = document.createElement('File')
        file_element.setAttribute('FileType', 'Native' if for_nli else 'Text')
        files_list.appendChild(file_element)

        if for_nli:
            self.serialize_content_file(document, file_element, entry_map)
        else:
            inline_content = document.createElement('InlineContent')
            file_element.appendChild(inline_content)
            inline_content.appendChild(document.createTextNode(str(self.data)))
